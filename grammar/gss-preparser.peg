{
  var parser, flatten; 

  parser = this;

  String.prototype.trim = String.prototype.trim || function trim() { return this.replace(/^\s\s*/, '').replace(/\s\s*$/, ''); };

  flatten = parser.flatten = function (array, isShallow) {
    var index = -1,
      length = array ? array.length : 0,
      result = [];

    while (++index < length) {
      var value = array[index];

      if (value instanceof Array) {
        Array.prototype.push.apply(result, isShallow ? value : flatten(value));
      }
      else {
        result.push(value);
      }
    }
    return result;
  }
  parser.results = []
  parser.stringify = function (array) {
    return flatten(array).join("").trim()
  }

}

start
  = LineTerminator* s:(statement)+  {return s}
  / _

statement
  = gssBlob
  / cssBlock 
  / cssLine

gssBlob
  = ccss
  / vfl
  / gtl

ccss
  = ccss:(_ char+ _ ccssOp anytoend)  { return ['ccss', parser.stringify(ccss)]; }
  / stay:( _ "@" ("-gss-")? "stay" anytoend)    { return ['ccss', parser.stringify(stay)]; }
  / chain:( _ "@" ("-gss-")? "chain" anytoend)    { return ['ccss', parser.stringify(chain)]; }
  / forlooper:( _ "@" ("-gss-")? ("for-each" / "for-all") [^`]+ "```" [^`]+ "```" anytoend) { return ['ccss', parser.stringify(forlooper)]; }
  

ccssOp
  = ">=" / "==" / "<="

vfl
  = vfl:( _ ("@-gss-" / "@") ("horizontal" / "vertical" / "h" / "v") anytoend)    { return ['vfl', parser.stringify(vfl)]; }

gtl
  = gtl:(_ "@-gss-" ("layout" / "template") multitoend)    { return ['gtl', parser.stringify(gtl)]; }

cssBlock
  = block:(anychar+ multitoend)    { return ['css', parser.stringify(block)]; }
 
cssLine
  = line:(anychar+ anytoend)   { return ['css', parser.stringify(line)]; }

comment
  = _ "/*" [^*]* "*"+ ([^/*] [^*]* "*"+)* "/" _ LineTerminator*  {return ""}

//css
//  = css:(.)+  {return ['css', parser.stringify(css)]}
_
  = space* 

__
  = space+
  
space
  = " "
  / [\t]
  / [\u00A0] //NO-BREAK SPACE
  

char
  = [a-zA-Z0-9_#.\[\]\-]

anychar
  = [a-zA-Z0-9 .,#:{}@+?!^=()_\-$*/\\]

multitoend
  = [^}]* "}" _ LineTerminator*

anytoend
  = [^;]* ";" _ LineTerminator*

LineTerminator
  = ([\n\r\u2028\u2029] / "\r\n") _
  / comment 
